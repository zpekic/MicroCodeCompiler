//-------------------------------------------------------
// Intel 8080 core microcode. (c) zpekic@hotmail.com 2018
//-------------------------------------------------------
// Based on following sources:
// http://www.classiccmp.org/dunfield/r/8080.txt
// http://www.pastraiser.com/cpu/i8080/i8080_opcodes.html


	.mapper 8 256
	.microcode 48 256

//-----------------------------------------------------
// input field must appear on right side, only width is checked
//-----------------------------------------------------
//DIN	.inpfield 8 // 8 bit data bus as input
//INT	.inpfield 1 // 1 == interrupt request
READY	.inpfield 1 // 1 == bus is ready
HOLD	.inpfield 1 // 1 == hold request

// ------------------------------------------------------
// Microinstruction word - definition start
// ------------------------------------------------------
HLDA		.valfield 1 range 0 .. 1 default 0 // 1 == holding bus in tri-state
WAITOUT		.valfield 1 range 0 .. 1 default 0 // 1 == holding bus in wait mode
nINTA		.valfield 1 range 0 .. 1 default 1 // 0 == interrupt ack
nIOR		.valfield 1 range 0 .. 1 default 1 // 0 == read i/o
nIOW		.valfield 1 range 0 .. 1 default 1 // 0 == write i/o
nMEMR		.valfield 1 range 0 .. 1 default 1 // 0 == write memory
nMEMW		.valfield 1 range 0 .. 1 default 1 // 0 == read memory

dst		.valfield 3 values qreq, nop, rama, ramf, ramqd, ramd, ramqu, ramu default qreq  
fun		.valfield 3 values add, subr, subs, or, and, notrs, exor, exnor default add  
src		.valfield 3 values aq, ab, zq, zb, za, da, dq, dz default aq  
rama		.muxfield 2 values direct_l, ireg543, 
ramb		.muxfield 2 values direct_h, ireg210,
cin		.muxfield 2 values zero, one, flag_c, carry default zero;
carry		.muxfield 1 value nop, alu_c default nop;

areg		.muxfield 1 registered values nop, y default nop
ireg		.muxfield 1 registered values nop, dbin default nop
flag_ie		.muxfield 2 registered values nop, zero, one, default nop
flag_s		.muxfield 3 registered values nop, zero, one, alu, din,,, default nop
flag_z		.muxfield 3 registered values nop, zero, one, alu, din,,, default nop
flag_a		.muxfield 3 registered values nop, zero, one, alu, din,,, default nop
flag_p		.muxfield 3 registered values nop, zero, one, alu, din,,, default nop
flag_c		.muxfield 3 registered values nop, zero, one, alu, din,,, default nop

direct		.valfield 8 range 0 .. $FF default 0

		// Sequencer control
instruction	.seqinstr 4 values next/next, repeat/next, repeat/return, gosub/next, fork/next, goto/next, goto/repeat, default next/next
condition	.seqcond  4 values TRUE, READY, HOLD, intreq, condition default TRUE
polarity	.seqinvert 1 values !!, ! default !! // 
direct		.seqdirect 8 range 0 .. $FF default $0

// ------------------------------------------------------
// Microinstruction word - definition end
// ------------------------------------------------------
clear_b		.alias dst = ramf, fun = and, src = dz		// ram(b) <= 0
read_a		.alias dst = nop, fun = or, src = za 		// y = ram(a)
read_a_inc_b	.alias dst = rama, fun = add, src = zb  	// y = ram(a), ram(b) = ram(b) + carry
copy_a_to_b	.alias dst = ramf, fun = or, src = za		// ram(b) <= ram(a)
load_b		.alias dst = ramf, fun = or, src = dz		// ram(b) <= d
complement_b	.alias dst = ramf, fun = exnor, src = zb	// ram(b) <= ~ram(b)
load_q		.alias dst = qreg, fun = or, src = dq		// q <= d
b_is_a_plus_q	.alias dst = ramf, fun = add, src = aq		// ram(b) <= ram(a) + q
b_is_a_plus_0	.alias dst = ramf, fun = add, src = za		// ram(b) <= ram(a) + 0 + carry
b_is_a_plus_b	.alias dst = ramf, fun = add, src = ab		// ram(b) <= ram(b) + ram(a) + carry

bus_memory_read_nowait	.alias nMEMR = 0
bus_memory_read_wait	.alias nMEMR = 0, WAITOUT = 1
bus_memory_write_nowait	.alias nMEMW = 0
bus_memory_write_wait	.alias nMEMW = 0, WAITOUT = 1
bus_io_read_nowait	.alias nIOR = 0
bus_io_read_wait	.alias nIOR = 0, WAITOUT = 1
bus_io_write_nowait	.alias nIOW = 0
bus_io_write_wait	.alias nIOW = 0, WAITOUT = 1

		// reset signal will set uPC <= 0
		.org 0;		

		// clear PC.H and PC.L
Reset:		clear_ramb, ramb = direct_h, direct = $80;
		clear_ramb, ramb = direct_h, direct = $90;

		// disable interrupts
NoInterrupt:	flag_ie <= 0;

		// areg <= PC, note that areg loads from "top" so first LSB is pushed in, then MSB
NextInstr:	areg <= y, read_a, rama = direct_l, direct = $09, if HOLD then gosub HoldAck; 
		areg <= y, read_a, rama = direct_l, direct = $08, if intreq then gosub IntAck;
		ir <= dbus, bus_memory_read_nowait;
		ir <= dbus, bus_memory_read_wait, if !READY then repeat; // load instruction register
		// areg <= HL, PC <= PC + 1
		areg <= y, carry <= alu_c, read_a_inc_b, cin = one, ramb = direct_h, rama = direct_l, direct = $95, if HOLD then gosub HoldAck;  
		areg <= y, read_a_inc_b, cin = carry, ramb = direct_h, rama = direct_l, direct = $84, fork;

		// stay here until HOLD goes low
HoldAck:	HLDA = 1, if HOLD then repeat else return;

		
		// AReg <= PC, PC <= PC + 1
PCToAReg:	areg <= y, carry <= alu_c, read_a_inc_b, cin = one, ramb = direct_h, rama = direct_l, direct = $99, if HOLD then gosub HoldAck; 
		areg <= y, read_a_inc_b, cin = carry, ramb = direct_h, rama = direct_l, direct = $88, return; 

		// Temp.L <= M(PC), PC <= PC + 1
PullTempLByPC:	gosub PCToAReg;
		bus_memory_read_nowait; load_b; dmux = DIN, ramb = direct_h, direct = $B0;
		bus_memory_read_wait; load_b; dmux = DIN, ramb = direct_h, direct = $B0, if !READY then repeat else return;

		// Temp.H <= M(PC), PC <= PC + 1
PullTempHByPC:	gosub PCToAReg; 
		bus_memory_read_nowait; load_b; dmux = DIN, ramb = direct_h, direct = $A0;
		bus_memory_read_wait; load_b; dmux = DIN, ramb = direct_h, direct = $A0, if !READY then repeat else return;

		// AReg <= M(PC):M(PC), PC <= PC + 1
GetPortAddress:	gosub PullTempLByPC;
		areg <=y, read_a, rama = direct_l, direct = $0B, if HOLD then gosub HoldAck;	
		areg <=y, read_a, rama = direct_l, direct = $0B, return;	

//----------------------------------------------------------------------
//Inst      Encoding          Flags   Description
//----------------------------------------------------------------------

//MOV D,S   01DDDSSS          -       Move register to register
		.map 01XXXXXX
mov_rr:		copy_a_to_b, ramb = ireg543, rama = ireg210; goto NextInstr;

		// more specific form mov (hl), s overrides generic mov (HL was already in AReg)
		.map 01110XXX	
mov_mr:		bus_memory_write_nowait; read_a, rama = ireg210;
		bus_memory_write_wait; read_a, rama = ireg210, if READY then goto NextInstr else repeat;

		.map 01XXX110	// more specific form mov d, (hl) overrides generic mov (HL was already in AReg)
mov_rm:		bus_memory_read_nowait; load_b; dmux = DIN, ramb = ireg543;
		bus_memory_read_wait; load_b; dmux = DIN, ramb = ireg543, if READY then goto NextInstr else repeat;

//HLT       01110110          -       Halt processor
		// more specific form mov (hl), (hl) is actually a halt!
		.map 01110110   
halt:		if HOLD then gosub HoldAck;
		if intreq then goto IntAck;
		goto halt;

//MVI D,#   00DDD110 db       -       Move immediate to register
		.map 00XXX110
mov_ri:		gosub PullTempLByPC;
		copy_a_to_b, ramb = ireg543, rama = direct_l, direct = $0B, goto NextInstr;

		// more specific form MOV (HL), #
		.map 00110110
mov_mi:		gosub PullTempLByPC;
		AReg <= y, read_a, rama = direct_l, direct = $05, if HOLD then gosub HoldAck; 
		Areg <= y, read_a, rama = direct_l, direct = $04, if HOLD then gosub HoldAck;
WriteTempL:	bus_memory_write_nowait; read_a, rama = direct_l, direct = $0B;
		bus_memory_write_wait; read_a, rama = direct_l, direct = $0B, if READY then goto NextInstr else repeat;


LXI RP,#  00RP0001 lb hb    -       Load register pair immediate
LDA a     00111010 lb hb    -       Load A from memory
STA a     00110010 lb hb    -       Store A to memory
LHLD a    00101010 lb hb    -       Load H:L from memory
SHLD a    00100010 lb hb    -       Store H:L to memory
LDAX RP   00RP1010 *1       -       Load indirect through BC or DE
STAX RP   00RP0010 *1       -       Store indirect through BC or DE

//XCHG      11101011          -       Exchange DE and HL content
	  	.map 11101011
xchg:		copy_a_to_b, ramb = direct_h, rama = direct_l, direct = $65, if HOLD then gosub HoldAck; 	//T <= L
		copy_a_to_b, ramb = direct_h, rama = direct_l, direct = $53, if HOLD then gosub HoldAck; 	//L <= E
		copy_a_to_b, ramb = direct_h, rama = direct_l, direct = $36, if HOLD then gosub HoldAck; 	//E <= T
		copy_a_to_b, ramb = direct_h, rama = direct_l, direct = $64, if HOLD then gosub HoldAck; 	//T <= H
		copy_a_to_b, ramb = direct_h, rama = direct_l, direct = $42, if HOLD then gosub HoldAck; 	//H <= D
		copy_a_to_b, ramb = direct_h, rama = direct_l, direct = $26, goto NextInstr; 			//D <= T

//ADD S     10000SSS          ZSPCA   Add register to A
		.map 10000XXX
add_ar:		flag_c <= zero, goto adc_ar;

		.map 10000110
add_am:		flag_c <= zero, goto adc_am;

ADI #     11000110 db       ZSCPA   Add immediate to A

//ADC S     10001SSS          ZSCPA   Add register to A with carry
		.map 10001XXX
adc_ar:		flag_z = alu, flag_s = alu, flag_c = alu, flag_p = alu, flag_a = alu, b_is_a_plus_b, cin = flag_c, ramb = direct_h, rama = ireg210, direct = $70, goto NextInstr;

		.map 10001110
adc_am:		gosub ReadM;
		flag_z = alu, flag_s = alu, flag_c = alu, flag_p = alu, flag_a = alu, b_is_a_plus_b, cin = flag_c, ramb = direct_h, rama = direct_l, direct = $76, goto NextInstr;

//ACI #     11001110 db       ZSCPA   Add immediate to A with carry
		.map 11001110
add_ai:		gosub PullTempLByPC;
		flag_z = alu, flag_s = alu, flag_c = alu, flag_p = alu, flag_a = alu, b_is_a_plus_b, cin = flag_c, ramb = direct_h, rama = direct_l, direct = $7B, goto NextInstr;
		
//SUB S     10010SSS          ZSCPA   Subtract register from A
		.map 10010XXX
sub_ar:		flag_c <= zero, goto sbb_ar;

		.map 10010110
sub_am:		flag_c <= zero, goto sbb_am;

//SUI #     11010110 db       ZSCPA   Subtract immediate from A
		.map 11010110
sub_ai:		flag_c <= zero, goto sbb_ai;

//SBB S     10011SSS          ZSCPA   Subtract register from A with borrow

//SBI #     11011110 db       ZSCPA   Subtract immediate from A with borrow
		.map 11011110
sbb_ai:		gosub PullTempLByPC;
		flag_z = alu, flag_s = alu, flag_c = !alu, flag_p = alu, flag_a = alu, b_is_b_minus_a, cin = !flag_c, ramb = direct_h, rama = direct_l, direct = $7B, goto NextInstr;

INR D     00DDD100          ZSPA    Increment register
DCR D     00DDD101          ZSPA    Decrement register
INX RP    00RP0011          -       Increment register pair
DCX RP    00RP1011          -       Decrement register pair
DAD RP    00RP1001          C       Add register pair to HL (16 bit add)
DAA       00100111          ZSPCA   Decimal Adjust accumulator
ANA S     10100SSS          ZSCPA   AND register with A
ANI #     11100110 db       ZSPCA   AND immediate with A
ORA S     10110SSS          ZSPCA   OR  register with A
ORI #     11110110          ZSPCA   OR  immediate with A
XRA S     10101SSS          ZSPCA   ExclusiveOR register with A
XRI #     11101110 db       ZSPCA   ExclusiveOR immediate with A
CMP S     10111SSS          ZSPCA   Compare register with A
CPI #     11111110          ZSPCA   Compare immediate with A
RLC       00000111          C       Rotate A left
RRC       00001111          C       Rotate A right
RAL       00010111          C       Rotate A left through carry
RAR       00011111          C       Rotate A right through carry

//CMA       00101111          -       Complement A
		.map 00101111
Cma:		complement_b, ramb = direct_h, direct = $70, goto NextInstr;

//CMC       00111111          C       Compliment Carry flag
		.map 00111111
Cmc:		if !flag_c then goto Stc;
		flag_c <= zero, goto NextInstr;

//STC       00110111          C       Set Carry flag
		.map 00110111
Stc:		flag_c <= one, goto NextInstr;

//JMP a     11000011 lb hb    -       Unconditional jump
		.map 11000011
Jmp:		gosub PullTempLByPC;
		gosub PullTempHByPC;
CopyTempToPC:	copy_a_to_b, ramb = direct_h, rama = direct_l, direct = $9B, if HOLD then gosub HoldAck; // PC.L <= Temp.L
		copy_a_to_b, ramb = direct_h, rama = direct_l, direct = $8A, goto NextInstr;		// PC.H <= Temp.H

//Jccc a    11CCC010 lb hb    -       Conditional jump
		.map 11XXX010
JCond:		if condition then goto Jmp;
IncPCby2:	load_q, direct = $02, dmux = direct, if HOLD then gosub HoldAck; // Q <= $02
		b_is_a_plus_q, ramb = direct_h, rama = direct_l, cin = zero, direct = $99, if HOLD then gosub HoldAck;
		b_is_a_plus_0, ramb = direct_h, rama = direct_l, cin = carry, direct = $88, goto NextInstr;

//CALL a    11001101 lb hb    -       Unconditional subroutine call
		.map 11001101
Call:		gosub PullTempLByPC;
		gosub PullTempHByPC;
PushPC:		gosub PushPCHBySP;
		gosub PushPCLBySP;
		goto CopyTempToPC;

//Cccc a    11CCC100 lb hb    -       Conditional subroutine call
		.map 11XXX100
CCond:		if condition then goto Call;
		goto IncPCBy2;

//RET       11001001          -       Unconditional return from subroutine
		.map 11001001
Ret:		gosub PullPCLBySP;
		gosub PullPCHBySP;
		goto NextInstr;

//Rccc      11CCC000          -       Conditional return from subroutine
		.map 11XXX000
RCond:		if condition then goto Ret;
		goto NextInstr;

//RST n     11NNN111          -       Restart (Call n*8)
		.map 11XXX111
Rst:		qreg_or_dz, dmux = direct, direct = %00111000, if HOLD then gosub HoldAck; // Q <= %00111000
		ramf_and_dq, dmux = ir, ramb = direct_h, direct = $B0, if HOLD then gosub HoldAck; // Temp.L <= IR and %00111000
		ramf_and_zb, ramb = direct_h, direct = $A0, goto PushPC;			   // Temp.H <= 0

//PCHL      11101001          -       Jump to address in H:L
		.map 11101001
Pchl:		copy_a_to_b, ramb = direct_h, rama = direct_l, direct = $95, if HOLD then gosub HoldAck;
		copy_a_to_b, ramb = direct_h, rama = direct_l, direct = $84, goto NextInstr;

PUSH RP   11RP0101 *2       -       Push register pair on the stack
POP RP    11RP0001 *2       *2      Pop  register pair from the stack
XTHL      11100011          -       Swap H:L with top word on stack

//SPHL      11111001          -       Set SP to content of H:L
		.map 11111001
sphl:		copy_a_to_b, ramb = direct_h, rama = direct_l, direct = $F5, if HOLD then gosub HoldAck;	//SP.L <= L
		copy_a_to_b, ramb = direct_h, rama = direct_l, direct = $E4, goto NextInstr;		//SP.H <= H

//IN p      11011011 pa       -       Read input port into A
		.map 11011011
In:		gosub GetPortAddress;
		bus_io_read_nowait, ramf_or_zd, ramb = direct_h, direct = $70;
		bus_io_read_wait, ramf_or_zd, ramb = direct_h, direct = $70, if READY then goto NextInstr else repeat;
		
//OUT p     11010011 pa       -       Write A to output port
		.map 11010011
Out:		gosub GetPortAddress;
		bus_io_write_nowait, ramf_or_zd, ramb = direct_h, direct = $70;
		bus_io_write_wait, ramf_or_zd, ramb = direct_h, direct = $70, if READY then goto NextInstr else repeat;

//EI        11111011          -       Enable interrupts
		.map 11111011
ei:		flag_ie <= 1; goto NextInstr;

//DI        11110011          -       Disable interrupts
		.map 11110011
di:		goto NoInterrupt;

//NOP       00000000          -       No operation
		.map 00000000
		goto NextInstr;

//8080 instruction encoding:

//Conventions in instruction source:
//    D   = Destination register (8 bit)
//    S   = Source register (8 bit)
//    RP  = Register pair (16 bit)
//    #   = 8 or 16 bit immediate operand
//    a   = 16 bit Memory address
//    p   = 8 bit port address
//    ccc = Conditional

//Conventions in instruction encoding:
//    db  = Data byte (8 bit)
//    lb  = Low byte of 16 bit value
//    hb  = High byte of 16 bit value
//    pa  = Port address (8 bit)

//Condition code 'CCC' fields: (FLAGS: S Z x A x P x C)
//    000=NZ  ('Z'ero flag not set)
//    001=Z   ('Z'ero flag set)
//    010=NC  ('C'arry flag not set)
//    011=C   ('C'arry flag set)
//    100=PO  ('P'arity flag not set - ODD)
//    101=PE  ('P'arity flag set - EVEN)
//    110=P   ('S'ign flag not set - POSITIVE)
//    111=M   ('S'ign flag set - MINUS)
//Implementation: "condition" input is the output of the hard-wired 8 to 1 mux above

//Dest and Source reg fields:
//0    000=B
//1    001=C
//2    010=D
//3    011=E
//4    100=H
//5    101=L
//6    110=M   (Memory reference through address in H:L, but also used as temporary 8-bit reg)
//7    111=A   (Accumulator)
//8   1000=PC.H
//9   1001=PC.L
//A   1010=Temp.H Temporary high
//B   1011=Temp.L Temporary low
//C   1100=not used
//D   1101=not used
//E   1110=SP.H
//F   1111=SP.L

//Register pair 'RP' fields:
//    00=BC   (B:C as 16 bit register)
//    01=DE   (D:E as 16 bit register)
//    10=HL   (H:L as 16 bit register)
//    11=SP   (Stack pointer, refers to PSW (FLAGS:A) for PUSH/POP)
//*1 = Only RP=00(BC) and 01(DE) are allowed for LDAX/STAX
//*2 = RP=11 refers to PSW for PUSH/POP (cannot push/pop SP).
//     When PSW is POP'd, ALL flags are affected.
		  